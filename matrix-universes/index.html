<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Marvel Comics: Film Universes Co-occurrence</title>
    <meta charset="UTF-8">
    <meta name="description" content="Marvel Comics: Film Universes Co-occurrence">
    <meta name="keywords" content="Marvel, Avengers, X-Men, The Defenders, Stan Lee, Professor Xavier, Captain America, Iron Man, Wolverine, Claire Temple, Nick Fury, Magneto, Cyclops, Thor, Black Widow, Beast, Phoenix, Storm, Pepper Potts, Mystique, War Machine, Falcon, Heimdall, Howard Stark, Hulk">
    <meta name="author" content="Jeffrey Lancaster">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css" />
    <script src="//d3js.org/d3.v2.min.js" charset="utf-8"></script>
    <script src="//d3js.org/d3.v4.min.js" charset="utf-8"></script>
  </head>
  <body>

    <p><select id="order">
      <option value="name">Order by Name</option>
      <option value="count">Order by Frequency</option>
      <option value="group">Order by Cluster</option>
    </select></p>
    
    <svg class="matrix"></svg>

    <script>
/* HELPFUL FUNCTIONS */

// to convert scene start/end times into seconds
function sec(timeString){
  var sec = 0;
  if (timeString.length == 0) return sec;
  var splitArray = timeString.split(":");
  sec = 3600*parseFloat(splitArray[0])+60*parseFloat(splitArray[1])+parseFloat(splitArray[2]);
  return sec;
}

// to convert seconds into hh:mm:ss
function secondsToHMS(d) {
  var date = new Date(null);
  date.setSeconds(d); // specify value for SECONDS here
  return date.toISOString().substr(11, 8);
}

// to dedpulicate an array
function onlyUnique(value, index, self) { 
  return self.indexOf(value) === index;
}

// to sort the array of objects
function compare(a,b) {
  if (a.name < b.name)
    return -1;
  if (a.name > b.name)
    return 1;
  return 0;
}

var mcuFilm, mcuTV, xmenFilm;
var matrixObject = { // object for nodes & links
  "nodes": [],
  "links": []
}
var characterMatrix = [[]];
var uniqueCharacters = {};
var groupArray = [
  "Ant-Man",
  "Iron Man",
  "Thor",
  "Spider-Man",
  "Black Panther",
  "Doctor Strange",
  "Guardians of the Galaxy",
  "Hulk",
  "Captain America",
  "Avengers",
  "Stan Lee",
  "Deadpool",
  "X-Men",
  "Wolverine",
  "Iron Fist",
  "Jessica Jones",
  "Luke Cage",
  "Daredevil",
  "The Punisher"
];

var config = {
  "title":"Film Universes Co-Occurrence",
  "size": 3000,
  "margin": {
    "top": 200,
    "right": 50,
    "bottom": 60,
    "left": 350
  }
}

d3.queue()
  .defer(d3.json, '../data/mcu-film.json')
  .defer(d3.json, '../data/mcu-netflix.json')
  .defer(d3.json, '../data/x-men-film.json')
  .await(ready);

function ready(error, mcufilm, mcunetflix, xmenfilm) {
  if (error) throw error;
  console.log("now that the files are loaded... do magic.");

  /* DIGEST FILES TO MAKE CHARACTER MATRIX */
  var films = [...mcufilm.films, ...mcunetflix.films, ...xmenfilm.films];
  
  // make uniqueCharacters, make groupArray
  films.forEach(function(val, i){
    val.characters.forEach(function(value, j){
      if(!uniqueCharacters[value]){
        uniqueCharacters[value.name] = value;
      }
      //groupArray.push(value.mainseries);
    });
  });


  // deduplicate the groupArray
  //groupArray = groupArray.filter(onlyUnique).sort();
  //console.log(groupArray);

  var uniqueCharactersArray = [];
  for(var i in uniqueCharacters){
    // assign a group to each character...
    uniqueCharacters[i].group = groupArray.indexOf(uniqueCharacters[i].mainseries);
    // ... and make uniqueCharacters into an array
    uniqueCharactersArray.push(uniqueCharacters[i].name);
  };
  uniqueCharactersArray.sort();

  // count the number of films & series for each character
  for(var i in films){
    if(films[i].characters.length > 1){
      films[i].characters.forEach(function(item, j){
        if(!uniqueCharacters[item.name].films){
          uniqueCharacters[item.name].films = {}
        }
        if(!uniqueCharacters[item.name].series){
          uniqueCharacters[item.name].series = {}
        }
        uniqueCharacters[item.name].films[films[i].name] = true;
        uniqueCharacters[item.name].series[films[i].series] = true;
      });
    }
  }
  for(var i in uniqueCharacters){
    if(uniqueCharacters[i].films){
      uniqueCharacters[i].films = Object.keys(uniqueCharacters[i].films).length;
    }
    if(uniqueCharacters[i].series){
      uniqueCharacters[i].series = Object.keys(uniqueCharacters[i].series).length;
    }
  }    

  // create the co-occurrence matrix for all characters
  for(i=0; i<uniqueCharactersArray.length; i++){
    characterMatrix[i] = [];
    for(j=0; j<uniqueCharactersArray.length; j++){
      characterMatrix[i][j] = 0;
    }
  }

  for(var i in films){
    if(films[i].characters.length > 1){
      films[i].characters.forEach(function(item, j){
        films[i].characters.forEach(function(val, k){
          if(uniqueCharactersArray.includes(item.name) && uniqueCharactersArray.includes(val.name)){
            characterMatrix[uniqueCharactersArray.indexOf(item.name)][uniqueCharactersArray.indexOf(val.name)]++;
          }
        });
      });
    }
  }

  //console.log(characterMatrix);

  for(i=0; i < characterMatrix.length; i++){
    for(j=0; j < i; j++){
      if(characterMatrix[i][j] != 0){
        matrixObject.links.push({"source": i, "target": j, "value": characterMatrix[i][j]});
      }
    }
  }

  for(i=0; i<uniqueCharactersArray.length; i++){
    matrixObject.nodes[i] = {
      "name": uniqueCharactersArray[i],
      "group": uniqueCharacters[uniqueCharactersArray[i]].group,
      "count": uniqueCharacters[uniqueCharactersArray[i]].films
    };
  }
  
  console.log(matrixObject);

  var margin = config.margin,
    width = config.size,
    height = config.size;

  var x = d3.scale.ordinal().rangeBands([0, width]),
    z = d3.scale.linear().domain([0, 20]).clamp(true),
    //c = d3.scale.category20().domain(d3.range(20));
    c = d3.scale.category10().domain(d3.range(10));
  var svg = d3.select("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .style("margin-left", (-margin.left + 50) + "px")
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var matrix = [],
    nodes = matrixObject.nodes,
    n = nodes.length;

  // Compute index per node.
  nodes.forEach(function(node, i) {
    node.index = i;
    //node.count = 0;
    matrix[i] = d3.range(n).map(function(j) { return {x: j, y: i, z: 0}; });
  });

  // Convert links to matrix; count character occurrences.

  // matrixObject.links.forEach(function(link) {
  //   matrix[link.source][link.target].z += link.value;
  //   matrix[link.target][link.source].z += link.value;
  //   matrix[link.source][link.source].z += link.value;
  //   matrix[link.target][link.target].z += link.value;
  //   nodes[link.source].count += link.value;
  //   nodes[link.target].count += link.value;
  // });
  // console.log(matrix);
  
  characterMatrix.forEach(function(val, i){
    characterMatrix[i].forEach(function(item, j){
      matrix[i][j].z = characterMatrix[i][j];
    })
  })

  // Precompute the orders.
  var orders = {
    name: d3.range(n).sort(function(a, b) { return d3.ascending(nodes[a].name, nodes[b].name); }),
    count: d3.range(n).sort(function(a, b) { return nodes[b].count - nodes[a].count; }),
    group: d3.range(n).sort(function(a, b) { return nodes[a].group - nodes[b].group; })
  };

  // The default sort order.
  x.domain(orders.name);

  svg.append("rect")
      .attr("class", "background")
      .attr("width", width)
      .attr("height", height);

  var row = svg.selectAll(".row")
      .data(matrix)
    .enter().append("g")
      .attr("class", "row")
      .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
      .each(row);

  row.append("line")
      .attr("x2", width);

  row.append("text")
      .attr("x", -6)
      .attr("y", x.rangeBand() / 2)
      .attr("dy", ".32em")
      .attr("text-anchor", "end")
      .text(function(d, i) { return nodes[i].name; });

  var column = svg.selectAll(".column")
    .data(matrix)
    .enter().append("g")
      .attr("class", "column")
      .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

  column.append("line")
      .attr("x1", -width);

  column.append("text")
      .attr("x", 6)
      .attr("y", x.rangeBand() / 2)
      .attr("dy", ".32em")
      .attr("text-anchor", "start")
      .text(function(d, i) { return nodes[i].name; });

  function row(row) {
    var cell = d3.select(this).selectAll(".cell")
        .data(row.filter(function(d) { return d.z; }))
      .enter().append("g")
      .append("rect")
        .attr("class", "cell")
        .attr("x", function(d) { return x(d.x); })
        .attr("width", x.rangeBand())
        .attr("height", x.rangeBand())
        .style("fill-opacity", function(d) { return z(d.z)/0.24; })
        .style("fill", function(d) { return nodes[d.x].group == nodes[d.y].group ? c(nodes[d.x].group) : "#666666"; })
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
      .append("title")
        .text(function(d, i) {
          if(d.x == d.y){
            return nodes[d.x].name + " in " + d.z + " movies/shows with other characters."
          } else {
            return nodes[d.x].name + " and " + nodes[d.y].name + " together in " + d.z + " movies/shows.";
          }
        });
  }

  function mouseover(p) {
    d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
    d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });
  }

  function mouseout() {
    d3.selectAll("text").classed("active", false);
  }

  d3.select("#order").on("change", function() {
    clearTimeout(timeout);
    order(this.value);
  });

  function order(value) {
    x.domain(orders[value]);

    var t = svg.transition().duration(2500);

    t.selectAll(".row")
      .delay(function(d, i) { return x(i) * 4; })
      .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
    .selectAll(".cell")
      .delay(function(d) { return x(d.x) * 4; })
      .attr("x", function(d) { return x(d.x); });

    t.selectAll(".column")
      .delay(function(d, i) { return x(i) * 4; })
      .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });
  }

  var timeout = setTimeout(function() {
    order("group");
    d3.select("#order").property("selectedIndex", 2);
    }, 5000);

};

    </script>
  </body>
</html>
